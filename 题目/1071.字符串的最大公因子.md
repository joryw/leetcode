### 题目描述
对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。

返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。

 

示例 1：

输入：str1 = "ABCABC", str2 = "ABC"
输出："ABC"
示例 2：

输入：str1 = "ABABAB", str2 = "ABAB"
输出："AB"
示例 3：

输入：str1 = "LEET", str2 = "CODE"
输出：""


提示：

1 <= str1.length <= 1000
1 <= str2.length <= 1000
str1[i] 和 str2[i] 为大写英文字母
***
#### 解法一：数学
##### 性质：
**如果str1和str2拼接后等于str2和str1拼接的字符串，那么一定存在符合条件的字符串X**
##### 证明：
必要性：
* 假如存在X符合条件，则str1=X+X+……+X=n*X  str2=X+X+……X=m*X
* str1+str2=(n+m)X   同理str2+str1=(m+n)X=str1+str2

**充分性：**
* 等间隔取gcd(len1,len2)，可以找出最小公约数
    * gcd(a,b)=(b==0?a:gcd(b,a%b))
例如：![1](D:\leetcode\图片\1071.字符串的最大公因子\1.PNG)
```java
class Solution {
    public String gcdOfStrings(String str1, String str2) {
        int n=str1.length(),m=str2.length();
        //不能直接比较，直接比较的是内存地址，需要用equals()才能比较内容是否相等
        if(!(str1+str2).equals(str2+str1)){
            return "";
        }
        else{           
            //获取范围内字符串
            return str1.substring(0,gcd(n,m));
        }
    }
    public int  gcd(int len1,int len2){
        return len2==0?len1:gcd(len2,len1%len2);
    }
}
```
